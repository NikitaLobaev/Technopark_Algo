<h1>Модуль 1</h1>

<h2>Задача 1. Максимальная сумма</h2>
<p>Даны два массива целых чисел одинаковой длины A[0...n - 1] и B[0...n - 1]. Необходимо найти первую пару индексов i<sub>0</sub> и j<sub>0</sub>, i<sub>0</sub> ≤ j<sub>0</sub>, такую что A[i<sub>0</sub>] + B[j<sub>0</sub>] = max(A[i] + B[j]), где 0 ≤ i, j < n, i ≤ j. n ≤ 10<sup>5</sup>.</p>

<b>Требования.</b> Время работы O(n).

<table>
  <thead>
    <tr>
      <th>in</th>
      <th>out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>4 -8 6 0<br/>-10 3 1 1</td>
      <td>0 1</td>
    </tr>
  </tbody>
</table>

<hr/>

<h2>Задача 2. Пересечение множеств</h2>
<p>Даны два массива A[0...n - 1] и B[0...m - 1] неповторяющихся целых чисел, упорядоченных по возрастанию, n >> m (n намного больше m). Найдите их пересечение. n, k ≤ 10<sup>4</sup>.</p>

<b>Указания.</b> Для каждого B[i] сначала нужно определить диапазон для бинарного поиска размером порядка k, а потом уже в нём делать бинарный поиск.

<b>Требования.</b> Время работы O(m * log(k)), где k - позиция элемента B[m - 1] в массиве A. В процессе поиска очередного элемента B[i] в массиве A пользуйтесь результатом поиска элемента B[i - 1].

<table>
  <thead>
    <tr>
      <th>in</th>
      <th>out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>5<br/>3<br/>1 2 3 4 5<br/>1 3 5</td>
      <td>1 3 5</td>
    </tr>
  </tbody>
</table>

<hr/>

<h2>Задача 3. Очередь с помощью стеков</h2>
<p>Реализовать очередь с помощью двух стеков. Использовать стек, реализованный с помощью динамического буфера.</p>

<b>Требования.</b> Очередь должна быть реализована в виде класса. Стек тоже должен быть реализован в виде класса.

<i>Формат входных данных.</i> В первой строке задано количество команд (не более 10<sup>6</sup>). Каждая команда задаётся как два целых числа a и b:<br/>
a = 2 - pop front<br/>
a = 3 - push back<br/>
Команда 3 (a = 3) задана с неотрицательным параметром b. Если дана команда 2, то число b - ожидаемое значение. Если команда 2 вызвана для пустой структуры данных, то ожидается "-1".

<i>Формат выходных данных.</i> Требуется напечатать "YES" (без кавычек), если все ожидаемые значения совпали. Иначе, если хотя бы одно ожидание не оправдалось, напечатать "NO" (без кавычек).

<table>
  <thead>
    <tr>
      <th>in</th>
      <th>out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>3<br/>3 44<br/>3 50<br/>2 44</td>
      <td>YES</td>
    </tr>
    <tr>
      <td>2<br/>2 -1<br/>3 10</td>
      <td>YES</td>
    </tr>
    <tr>
      <td>2<br/>3 44<br/>2 66</td>
      <td>NO</td>
    </tr>
  </tbody>
</table>

<hr/>

<h2>Задача 4. Скользящий максимум</h2>
<p>Дан массив натуральных чисел A[0...n). Так же задан размер k некоторого окна (последовательно расположенных элементов массива) в этом массиве, k ≤ n. Требуется для каждого положения окна (от 0 и до n - k) вывести значение максимума в окне. n ≤ 10<sup>8</sup>.</p>

<b>Требования.</b> Время работы O(n * log(n)). Дополнительная память O(n).

<i>Формат входных данных.</i> Вначале вводится число n - количество элементов массива. Затем в следующей строке вводятся n значений элементов массива. Затем в следующей строке вводится число k - размер окна.

<i>Формат выходных данных.</i> Разделённые пробелом значения максимумов для каждого положения окна.

<table>
  <thead>
    <tr>
      <th>in</th>
      <th>out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>3<br/>1 2 3<br/>2</td>
      <td>2 3</td>
    </tr>
    <tr>
      <td>9<br/>0 7 3 8 4 5 10 4 6<br/>4</td>
      <td>8 8 8 10 10 10</td>
    </tr>
  </tbody>
</table>

<hr/>

<h2>Задача 5. Современники</h2>
<p>Группа людей называется современниками, если был такой момент, когда они могли собраться вместе. Для этого в этот момент каждому из них должно было уже исполниться 18 лет, но ещё не исполнится 80 лет. Дан список Жизни Великих Людей. Необходимо получиться максимальное количество современников. В день 18-летия человек уже может принимать участие в собраниях, а в день 80-летия и в день смерти уже не может.</p>

<b>Замечания.</b> Человек мог не дожить до 18-летия, либо умереть в день 18-летия. В этих случаях принимать участие в собраниях он не мог.

<b>Требования.</b> Реализовать и использовать сортировку слиянием. Программа должна поддерживать передачу функции сравнения снаружи. Время работы O(n * log(n)).

<table>
  <thead>
    <tr>
      <th>in</th>
      <th>out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>3<br/>2 5 1980 13 11 2055<br/>1 1 1982 1 1 2030<br/>2 1 1920 2 1 2000</td>
      <td>3</td>
    </tr>
  </tbody>
</table>

<hr/>

<h2>Задача 6. Порядковые статистики</h2>
<p>Даны неотрицательные целые числа n и k и массив целых чисел из диапазона [0...10<sup>9</sup>] размера n. Требуется найти k-ю порядковую статистику, то есть, напечатать число, которое стояло бы на позиции с индексом k (от 0 до n - 1) в отсортированном массиве.</p>

<b>Требования.</b> Среднее время работы O(n). Дополнительная память O(n). Должна быть отдельно написанная функция partition. Рекурсия запрещена. Решение должно поддерживать передачу функции сравнения снаружи. Реализовать стратегию выбора опорного элемента "медиана трёх". Функцию partition реализовать методом прохода двумя итераторами от начала масива к концу.

<table>
  <thead>
    <tr>
      <th>in</th>
      <th>out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>10 4<br/>1 2 3 4 5 6 7 8 9 10</td>
      <td>5</td>
    </tr>
    <tr>
      <td>10 0<br/>3 6 5 7 2 9 8 10 4 1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>10 9<br/>0 0 0 0 0 0 0 0 0 1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<hr/>

<h2>Задача 7. Поразрядная сортировка</h2>
<p>Дан массив неотрицательных целых 64-разрядных чисел размера n. Отсортировать массив методом поразрядной сортировки MSD по битам (бинарная QuickSort). n ≤ 10<sup>6</sup>.</p>

<b>Требования.</b> Время работы O(n).

<table>
  <thead>
    <tr>
      <th>in</th>
      <th>out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>3<br/>4 1000000 7</td>
      <td>4 7 1000000</td>
    </tr>
  </tbody>
</table>
