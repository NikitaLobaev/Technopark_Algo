<h1>Модуль 1</h1>

<h2>Задача 1. Максимальная сумма</h2>
<p>Даны два массива целых чисел одинаковой длины A[0...n - 1] и B[0...n - 1]. Необходимо найти первую пару индексов i<sub>0</sub> и j<sub>0</sub>, i<sub>0</sub> ≤ j<sub>0</sub>, такую что A[i<sub>0</sub>] + B[j<sub>0</sub>] = max(A[i] + B[j]), где 0 ≤ i, j < n, i ≤ j. n ≤ 10<sup>5</sup>.</p>

<b>Требования.</b> Время работы O(n).

<table>
  <thead>
    <tr>
      <th>in</th>
      <th>out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>4 -8 6 0<br/>-10 3 1 1</td>
      <td>0 1</td>
    </tr>
  </tbody>
</table>

<hr/>

<h2>Задача 2. Пересечение множеств</h2>
<p>Даны два массива неповторяющихся целых чисел A[0...n - 1] и B[0...m - 1], упорядоченных по возрастанию, n >> m (n намного больше m). Необходимо найти их пересечение. n, k ≤ 10<sup>4</sup>.</p>

<b>Указания.</b> Для каждого B[i] сначала нужно определить диапазон для бинарного поиска размером порядка k и в нём выполнять бинарный поиск.

<b>Требования.</b> Время работы O(m * log(k)), где k - позиция элемента B[m - 1] в массиве A. Для поиска очередного элемента B[i] в массиве A необходимо пользоваться результатом поиска элемента B[i - 1].

<table>
  <thead>
    <tr>
      <th>in</th>
      <th>out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>5<br/>3<br/>1 2 3 4 5<br/>1 3 5</td>
      <td>1 3 5</td>
    </tr>
  </tbody>
</table>

<hr/>

<h2>Задача 3. Очередь с помощью стеков</h2>
<p>Реализовать очередь с помощью двух стеков. Использовать стек, реализованный с помощью динамического буфера.</p>

<b>Требования.</b> Очередь должна быть реализована в виде класса. Стек тоже должен быть реализован в виде класса.

<i>Формат входных данных.</i> В первой строке задано количество команд (не более 10<sup>6</sup>). Каждая команда задаётся как два целых числа a и b:<br/>
a = 2 - pop front<br/>
a = 3 - push back<br/>
Команда 3 (a = 3) задана с неотрицательным параметром b. Если дана команда 2, то число b - ожидаемое значение. Если команда 2 вызвана для пустой структуры данных, то ожидается "-1".

<i>Формат выходных данных.</i> Требуется напечатать "YES" (без кавычек), если все ожидаемые значения совпали. Иначе, если хотя бы одно ожидание не оправдалось, напечатать "NO" (без кавычек).

<table>
  <thead>
    <tr>
      <th>in</th>
      <th>out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>3<br/>3 44<br/>3 50<br/>2 44</td>
      <td>YES</td>
    </tr>
    <tr>
      <td>2<br/>2 -1<br/>3 10</td>
      <td>YES</td>
    </tr>
    <tr>
      <td>2<br/>3 44<br/>2 66</td>
      <td>NO</td>
    </tr>
  </tbody>
</table>

<hr/>

<h2>Задача 4. Скользящий максимум</h2>
<p>Дан массив натуральных чисел A[0...n). Так же задан размер k некоторого окна (последовательно расположенных элементов массива) в этом массиве, k ≤ n. Необходимо для каждого положения окна (от 0 и до n - k) вывести значение максимума в окне. n ≤ 10<sup>8</sup>.</p>

<b>Требования.</b> Время работы O(n * log(n)). Дополнительная память O(n).

<i>Формат входных данных.</i> Вначале дано число n - количество элементов массива. Затем в следующей строке дано n значений элементов массива. Затем в следующей строке дано число k - размер окна.

<i>Формат выходных данных.</i> Разделённые пробелом значения максимумов для каждого положения окна.

<table>
  <thead>
    <tr>
      <th>in</th>
      <th>out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>3<br/>1 2 3<br/>2</td>
      <td>2 3</td>
    </tr>
    <tr>
      <td>9<br/>0 7 3 8 4 5 10 4 6<br/>4</td>
      <td>8 8 8 10 10 10</td>
    </tr>
  </tbody>
</table>

<hr/>

<h2>Задача 5. Современники</h2>
<p>Группа людей называется современниками, если был такой момент, когда они могли собраться вместе. Для этого в этот момент каждому из них должно было уже исполниться 18 лет, но ещё не исполнится 80 лет. Дан список Жизни Великих Людей. Необходимо вычислить максимальное количество современников. В день 18-летия человек уже может принимать участие в собраниях, а в день 80-летия и в день смерти уже не может.</p>

<b>Замечания.</b> Человек мог не дожить до 18-летия, либо умереть в день 18-летия. В этих случаях принимать участие в собраниях он не мог.

<b>Требования.</b> Реализовать и использовать сортировку слиянием. Программа должна поддерживать передачу функции сравнения снаружи. Время работы O(n * log(n)).

<table>
  <thead>
    <tr>
      <th>in</th>
      <th>out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>3<br/>2 5 1980 13 11 2055<br/>1 1 1982 1 1 2030<br/>2 1 1920 2 1 2000</td>
      <td>3</td>
    </tr>
  </tbody>
</table>

<hr/>

<h2>Задача 6. Порядковые статистики</h2>
<p>Даны неотрицательные целые числа n и k и массив целых чисел из диапазона [0...10<sup>9</sup>] размера n. Требуется найти k-ю порядковую статистику, то есть, вывести число, которое стояло бы на позиции с индексом k (от 0 до n - 1) в отсортированном массиве.</p>

<b>Требования.</b> Среднее время работы O(n). Дополнительная память O(n). Должна быть отдельно написанная функция partition. Рекурсия запрещена. Решение должно поддерживать передачу функции сравнения снаружи. Реализовать стратегию выбора опорного элемента "медиана трёх". Функцию partition реализовать методом прохода двумя итераторами от начала масива к концу.

<table>
  <thead>
    <tr>
      <th>in</th>
      <th>out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>10 4<br/>1 2 3 4 5 6 7 8 9 10</td>
      <td>5</td>
    </tr>
    <tr>
      <td>10 0<br/>3 6 5 7 2 9 8 10 4 1</td>
      <td>1</td>
    </tr>
    <tr>
      <td>10 9<br/>0 0 0 0 0 0 0 0 0 1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<hr/>

<h2>Задача 7. Поразрядная сортировка</h2>
<p>Дан массив неотрицательных целых 64-разрядных чисел размера n. Необходимо отсортировать массив методом поразрядной сортировки MSD по битам (бинарная быстрая сортировка). n ≤ 10<sup>6</sup>.</p>

<b>Требования.</b> Время работы O(n).

<table>
  <thead>
    <tr>
      <th>in</th>
      <th>out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>3<br/>4 1000000 7</td>
      <td>4 7 1000000</td>
    </tr>
  </tbody>
</table>

<hr/>

<h1>Модуль 2</h1>

<h2>Задача 1. Хеш-таблица</h2>
<p>Реализовать структуру данных типа "множество строк" на основе динамической хеш-таблицы с открытой адресацией. Хранимые строки непустые и состоят из строчных латинских букв.<br/>Хеш-функция строки должна быть реализована с помощью вычисления значения многочлена методом Горнера.<br/>Начальный размер таблицы должен быть равным 8. Перехеширование необходимо выполнять при добавлении элементов в случае, когда коэффициент заполнения таблицы достигает 3/4.<br/>Структура данных должна поддерживать операции добавления строки в множество, удаления строки из множества и проверки принадлежности данной строки множеству.</p>

<b>Указания.</b> Для разрешения коллизий необходимо использовать квадратичное пробирование. i-я проба: g(k, i) = (g(k, i - 1) + i) % m, m - степень двойки.

<b>Замечания.</b> При добавлении элемента в множество не гарантируется, что он отсутствует в этом множестве. При удалении элемента из множества не гарантируется, что он присутствует в этом множестве.

<b>Требования.</b> В хеш-таблице запрещено хранение указателей на описатель элемента.

<i>Формат входных данных.</i> Каждая строка входных данных задаёт одну операцию над множеством. Запись операции состоит из типа операции и следующей за ним через пробел строки, над которой проводится операция.<br/>Тип операции — один из трёх символов:<br/>+ означает добавление данной строки в множество;<br/>- означает удаление строки из множества;<br/>? означает проверку принадлежности данной строки множеству.<br/>

<i>Формат выходных данных.</i> Для каждой операции вывести одну из двух строк — "OK" или "FAIL" (без кавычек), в зависимости от того, присутствует ли данное слово в множестве.

<table>
  <thead>
    <tr>
      <th>in</th>
      <th>out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>+ hello<br/>+ bye<br/>? bye<br/>+ bye</br>- bye<br/>? bye<br/>? hello</td>
      <td>OK<br/>OK<br/>OK<br/>FAIL<br/>OK<br/>FAIL<br/>OK</td>
    </tr>
  </tbody>
</table>

<hr/>

<h2>Задача 2. Бинарное дерево. Порядок обхода</h2>
<p>Дано число N и последовательность, состоящая из N целых чисел из диапазона [-2<sup>31</sup>...2<sup>31</sup>]. Необходимо построить бинарное дерево, заданное наивным порядком вставки. То есть, при добавлении очередного числа K в дерево с корнем root при root→Key ≤ K узел K добавляется в правое поддерево root, иначе в левое поддерево root. Необходимо вывести элементы построенного бинарного дерева в порядке Post-Order (снизу вверх). N < 10<sup>6</sup>.</p>

<b>Требования.</b> Рекурсия запрещена. Решение должно поддерживать передачу функции сравнения снаружи.

<table>
  <thead>
    <tr>
      <th>in</th>
      <th>out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>3<br/>2 1 3</td>
      <td>1 3 2</td>
    </tr>
    <tr>
      <td>3<br/>1 2 3</td>
      <td>3 2 1</td>
    </tr>
    <tr>
      <td>3<br/>3 1 2</td>
      <td>2 1 3</td>
    </tr>
  </tbody>
</table>

<hr/>

<h2>Задача 3. Декартово дерево</h2>
<p>Дано число N и последовательность, состоящая из N пар целых чисел из диапазона [-2<sup>31</sup>...2<sup>31</sup>]. Необходимо остроить декартово дерево, состоящее из N узлов, характеризующихся парами чисел (X<sub>i</sub>, Y<sub>i</sub>), где X<sub>i</sub> — ключ, а Y<sub>i</sub> — приоритет в декартовом дереве.<br/>Затем нужно построить наивное дерево поиска по ключам X<sub>i</sub> методом из задачи 2.<br/>Необходимо вычислить и вывести разницу глубин наивного дерева поиска и декартова дерева. N < 10<sup>6</sup>.</p>

<b>Указания.</b> Разница глубин наивного дерева поиска и декартова дерева может быть отрицательна. Добавление узла в декартово дерево выполняйте следующим образом. При добавлении узла (X<sub>i</sub>, Y<sub>i</sub>) выполняйте спуск по ключу до узла P с меньшим приоритетом. Затем разбейте найденное поддерево по ключу X<sub>i</sub> так, чтобы в первом поддереве все ключи были меньше X<sub>i</sub>, а во втором поддереве больше или равны X<sub>i</sub>. Получившиеся два дерева сделайте дочерними для нового узла (X<sub>i</sub>, Y<sub>i</sub>). Новый узел вставьте на место узла P.

<table>
  <thead>
    <tr>
      <th>in</th>
      <th>out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>10<br/>5 11<br/>18 8<br/>25 7</br>50 12<br/>30 30<br/>15 15<br/>20 10<br/>22 5<br/>40 20<br/>45 9</td>
      <td>2</td>
    </tr>
    <tr>
      <td>10<br/>38 19<br/>37 5<br/>47 15<br/>35 0<br/>12 3<br/>0 42<br/>31 37<br/>21 45<br/>30 26<br/>41 6</td>
      <td>2</td>
    </tr>
  </tbody>
</table>

<hr/>

<h2>Задача 4. АВЛ-дерево. Порядковые статистики</h2>
<p>Дано число N и N строк. Каждая строка содержит команду добавления или удаления натуральных чисел, а также запрос на получение k-ой порядковой статистики. Команда добавления числа A задаётся положительным числом A, команда удаления числа A задаётся отрицательным числом "-A". Запрос на получение k-ой порядковой статистики задаётся числом k.</p>

<b>Требования.</b> Время выполнения запроса O(log(N)).

<table>
  <thead>
    <tr>
      <th>in</th>
      <th>out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>5<br/>40 0<br/>10 1<br/>4 1<br/>-10 0<br/>50 2</td>
      <td>40<br/>40<br/>10<br/>4<br/>50</td>
    </tr>
  </tbody>
</table>

<hr/>

<h2>Задача 5. Алгоритм Хаффмана сжатия данных</h2>
<p>Необходимо реализовать две функции для создания архива из одного файла и извлечения файла из архива.</p>

<b>Указания.</b> В архиве сохраняйте дерево Хаффмана и код Хаффмана от исходных данных. Дерево Хаффмана требуется хранить эффективно — не более 10 бит на каждый 8-битный символ.

<b>Требования.</b> Коэффициент сжатия должен быть меньше 1.

<hr/>

<h1>Модуль 3</h1>

<h2>Задача 1. Представление графа</h2>
<p>Дан базовый интерфейс для представления ориентированного графа:<br/>Необходимо написать несколько реализаций интерфейса:<br/>
1. ListGraph, хранящий граф в виде массива списков смежности.<br/>
2. MatrixGraph, хранящий граф в виде матрицы смежности.<br/>
3. SetGraph, хранящий граф в виде массива хеш-таблиц/сбалансированных деревьев поиска.<br/>
4. ArcGraph, хранящий граф в виде одного массива пар (from, to).<br/>
Также необходимо реализовать конструктор, принимающий</p>

<b>Требования.</b> Время работы

<hr/>

<h2>Задача 2. Количество различных путей</h2>
<p>Дан невзвешенный неориентированный граф, V — количество его вершин, E — количество его рёбер. В графе может быть несколько кратчайших путей между какими-то вершинами. Необходимо найти количество различных кратчайших путей между заданными вершинами. V ≤ 5 * 10<sup>4</sup>, E ≤ 2 * 10<sup>5</sup>.</p>

<b>Требования.</b> Время работы O(V + E).

<i>Формат входных данных.</i> В первой строке дано число V. Во второй строке дано число E. Затем перечислено E пар рёберных вершин графа. В последней строке дана пара вершин (u, w) для запроса.

<i>Формат выходных данных.</i> Количество кратчайших путей от вершины u к вершине w.

<table>
  <thead>
    <tr>
      <th>in</th>
      <th>out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>4<br/>5<br/>0 1<br/>0 2<br/>1 2<br/>1 3<br/>2 3<br/><br/>0 3</td>
      <td>2</td>
    </tr>
  </tbody>
</table>

<hr/>

<h2>Задача 3. Города. Алгоритм Дейкстры</h2>
<p>Необходимо отыскать самый выгодный маршрут между городами.</p>

<b>Требования.</b> Время работы O((N + M) * log(N)), где N — количество городов, M — количество известных дорог между ними.

<i>Формат входных данных.</i> В первой строке дано число N. Во второй строке дано число M. Затем перечислено M описаний известных дорог (u, w, t), где u — вершина, из которой исходит путь, w — вершина, в которую входит путь, t — время в пути. Последняя строка содержит маршрут, из какой вершины в какую необходимо добраться.

<i>Формат выходных данных.</i> Длина самого выгодного по времени маршрута.

<table>
  <thead>
    <tr>
      <th>in</th>
      <th>out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>6<br/>9<br/>0 3 1<br/>0 4 2<br/>1 2 7<br/>1 3 2<br/>1 4 3<br/>1 5 3<br/>2 5 3</td>
      <td>9</td>
    </tr>
  </tbody>
</table>

<hr/>

<h2>Задача 4. Пятнашки</h2>
<p>Необходимо реализовать алгоритм для решения игры в пятнашки. Решением является приведение пятнашек к следующему виду:<br/>
1 2 3 4<br/>
5 6 7 8<br/>
9 10 11 12<br/>
13 14 15 0<br/>
где 0 задаёт пустую ячейку. Достаточно найти хотя бы какое-то решение, число перемещений костяшек не обязано быть минимальным.</p>

<b>Требования.</b> Время работы

<i>Формат входных данных.</i> Начальная перестановка.

<i>Формат выходных данных.</i> Если решение существует, то выведите минимальное число перемещений костяшек, которое нужно сделать, чтобы достичь выигрышной конфигурации, а во второй строке выведите соответствующую последовательность ходов: L означает, что костяшка сдвинулась влево, R — вправо, U — вверх, D — вниз. Если таких последовательностей несколько, выведите любую из них. Если выигрышная конфигурация недостижима, выведите "-1" (без кавычек).

<table>
  <thead>
    <tr>
      <th>in</th>
      <th>out</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1 2 3 4<br/>5 6 7 8<br/>9 10 11 0<br/>13 14 15 12</td>
      <td>1<br/>U</td>
    </tr>
  </tbody>
</table>
